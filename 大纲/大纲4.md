### 01.修改url地址中的page1

```js
// 1.list.js
res.locals.pageHtml = paginationUtil({page: results[0].page, total: results[0].total, url: req.url})
// 2.pagination.js
const url = require('url')
const urlObject = url.parse(options.url, true)//不加true是键值对字符串加了是对象
const getUrl = (page) => {
    urlObject.query.page = page
    urlObject.search = undefined  //只有当search是undefined才会去用query拼接地址
    const urlStr = url.format(urlObject)
    return urlStr
}
const html = template(templateUrl, {
	。。。。
    getUrl   //把函数传进去
  })
// 3.上一页和下一页
<li class="prev"><a href="<%=getUrl(page-1)%>">«上一页</a></li>
<a href="<%=getUrl(i)%>"><%=i%></a>
<li class="next"><a href="<%=getUrl(page+1)%>">下一页»</a></li>
```

### 03.页码按钮功能实现

### 04.点击确认跳转输入的页码

```js
// 1.pagination.js
  const html = template(templateUrl, {
	........
    pathname:urlObject.pathname,
    query:urlObject.query
  })
// 2.pagunation.art
 <form action="{{pathname}}" autocomplete="off" style="display:inline-block">
 <span>
     {{each query value key}} 
{{if key!=='page'}}
 			<input type="hidden" name="{{key}}" value="{{value}}">                 
     {{/if}}{{/each}}      
 到第 <input type="text" name="page" class="page-num">页
<button class="page-confirm">确定</button> </span></form>              
```

### 05.路由规则

​	点击所有已经完事了 那接下来  我们要输入搜索 返回会列表

​	1.定义路由

​	2.改模板 (action、name 、button)

​	3.测试能不能跑通

```js
// 1.router.js
router.get('/search', listController.search)
// 2.header.art
<form action="/search" autocomplete="off" class="sui-form form-inline">
<div class="input-append">
 <input type="text" name='q' value="{{q}}" class="input-error input-xxlarge">
 <button class="sui-btn btn-xlarge btn-danger">搜索</button>
</div>
</form>
// 3.models/product.js 
exports.getProductBySearch = (q, page, per_page, sort) => {
    q = encodeURIComponent(q) //URL编码 地址栏不能有中文
 return axios.get(`products?page=${page}&per_page=${per_page}&sort=${sort}&q=${q}`)
        .then。。。。直接复制上个方法
}
// 4.list.js
exports.search = (req, res, next) => {
  const q = req.query.q
  const sort = req.query.sort || 'commend'
  const page = req.query.page || 1
  const per_page = 5
  productModel.getProductBySearch(q, page, per_page, sort)
    .then(data => {
      res.locals.q = q
      res.locals.sort = sort
      res.locals.list = data.list
      res.locals.pageHtml = paginationUtil({
        page: data.page,
        total: data.total,
        url: req.url
      })
      res.render('list.art')
    }).catch(err => next(err))
}
```

### 06.获取列表数据&处理url传中文及特殊字符

### 07.页面渲染完成

```js
// 1.修改面包屑
<ul class="fl sui-breadcrumb"> .....</ul>
{{if breadcrumb}}
	。。。。。。
{{else}}
    <li class="active">搜索"{{q}}"的结果为:</li>
{{/if}}
// 2.修改排序
{{if breadcrumb}}
      <ul class="sui-nav">......</ul>             
{{else}}       
     <ul class="sui-nav">
      <li class="{{sort=='commend'?'active':''}}">
      <a href="/search?q={{q}}&sort=commend">综合</a></li>
	把所有a的的href改成 上面的样子  &之前的改了
{{/if}}
```

### 08.路由规则

​	商品详情 首先定义路由规则

```js
const itemController = require('./controllers/item')
router.get('/item/:id', itemController.index)
exports.index = (req, res, next) => {
    res.render('item.art')
}
```

### 09.模板准备

```js
// item.art模板
<link rel="stylesheet" href="/assets/css/page-item.css">
<link rel="stylesheet" href="/assets/css/xzoom.css">
<script src="/assets/js/sui.tab.js"></script>
<script src="/assets/js/xzoom.min.js"></script>
<script>
  $(function ($) {
    $('.xzoom, .xzoom-gallery').xzoom({ tint: '#888', Xoffset: 15 })
  })
</script>
```

### 10.渲染分析

渲染模板之前 需要的数据

1. 面包屑导航

2. 商品基本信息

3. 商品图片

4. 商品简介

5. 相关商品列表起始就是猜你喜欢

   products接口能拿到4个数据 products/273?include=introduce,category,pictures

### 11.数据准备

 同时获取商品详情和猜你喜欢

```js
// 1. 根据id获取商品详情 products.js
exports.getProductById = (id) => {
    return axios.get(`/products/${id}?include=introduce,category,pictures`)
        .then(res => res.data)
        .catch(err => Promise.reject(err))
}
// 2. 修改获取猜你喜欢数据方法  传进limit 拼到接口后面 ‘limit=' + limit
// 3. 调用猜你喜欢的方法地方 传值
// 4. 把products.js 两个方法拿过来用 Promise.all包装一下 测试数据能不能拿到
exports.index = (req,res,next)=>{
  const id = req.params.id
  Promise.all([
    productModel.getProductById(id),
    productModel.getLikeProducts(5)
  ]).then(results=>{
    //商品详情
    res.locals.product = results[0]
    //相关商品
    res.locals.other = results[1]
    res.render('item.art')
  }).catch(err=>next(err))
}
```

### 12.渲染面包屑

```js
// item.art 面包屑是最小一级的分类 不需要 逻辑上的判断
<ul class="sui-breadcrumb">
 <li><a href="/list/{{product.category.parent.parent.id}}">{{product.category.parent.parent.name}}</a> </li>
<li><a href="/list/{{product.category.parent.id}}">
    {{product.category.parent.name}}</a></li>
<li><a href="/list/{{product.category.id}}">{{product.category.name}}</a></li>
 <li class="active">{{product.name}}</li>
</ul>
```

### 13.渲染xzoom结构

```js
 <div id="preview" class="spec-preview">
 <img class="xzoom" xoriginal="{{product.pictures[0].large}}" src="{{product.pictures[0].middle}}" width="100%">
 </div>
<div class="spec-scroll">
{{each product.pictures}}
<a href="{{$value.large}}"><img class="xzoom-gallery" src="{{$value.middle}}" width="60"></a>
{{/each}} </div>
```

### 14.加入购物车

​	大家我们加入购物车是不是的有id和数量啊 一起拼到加入购物车的后面

​	提交的话  我们用form表单  所以需要一个隐藏输入框 来存id

```js
<div class="summary-wrap">
<form action="/cart/add">
<div class="controls">
    <input type="hidden" name="id" value="{{product.id}}">
    <input type="number" name="num" value="1" min="1" class="itxt">
 </div>
<button class="sui-btn  btn-danger addshopcar">加入购物车</button>
</form>
```

### 15.商品简介&相关商品列表

```js
// 渲染商品列表 因为都是html 直接@ 
<div class="intro-detail">
{{@ product.introduce}}
 </div>
// 相关商品列表
<ul class="goods-list unstyled">
 {{each other}}
     <li>
         <div class="p-img"><img src="{{$value.thumbnail}}"></div>
					<div class="attr"><em>{{$value.name}}</em></div>
    			<div class="price"><strong>¥{{$value.price}}</strong></div>
        		<div class="operate"><a href="/cart/add?id={{$value.id}}"
```

### 16.路由规则

​	定义/cart/add 路由就方法  但是刷新会重复提交啊  添加完以后

​	 可以重新指向另一个路由  /cart/addCart/success

```js
// router.js
router.get('/cart/add', cartController.addCart)
router.get('/cart/addCartSuccess', cartController.addCartSuccess)
// controllers/cart.js
exports.addCart = (req, res, next) => {
    const id = req.query.id
    const num = req.query.num
    // 1.加入购物车
    res.redirect(`/cart/addCartSuccess?id=${id}&num=${num}`)
}
exports.addCartSuccess = (req, res, next) => {
    // 2.渲染加入的商品信息及加入的数量
    res.send('ok')
}
```

### 17.加入购物车分析

- 未登录:购物车操作     浏览器          cookie存储
- 已登录:购物车操作   php服务器     mysql存储 
- session区分已登录和未登录

### 18.配置session步骤

*在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session*

正题:

​	因为session浏览器关闭就消失 

​	所以要做session持久化 存到mysq 

```js
// 1. app.js  npm i express-session  express-mysql-session
// 1.session中间件 在自定义中间件前面
var session = require('express-session');
// 2.获取持久化构造函数
var MySQLStore = require('express-mysql-session')(session);
// 3.连接mysql的配置项 configs.mysql
// 4.初始化持久对象
var sessionStore = new MySQLStore(configs.mysql);
// configs.js
exports.mysql = {
  host: 'localhost',
  port: 3306,
  user: 'root',
  password: '123456',
  database: 'newshop'
}
// 5.使用session中间件
app.use(session({
key: 'PYGID', //session id
secret: 'pyg', //加密字符串
store: sessionStore, //持久化对象
resave: false, //重新保存session 当session有有效期的时候设置true
saveUninitialized: false //服务器启动初始化 还是使用session的时候初始化
}));
测试:req.session.user={}在addCart函数里面测
```