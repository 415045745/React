### 01.分类数据加载优化处理 

​	那我们的分类数据是不是 渲染的特别慢啊  渲染其他页面每次都得请求一遍

​	我们可以给数据做优化处理 怎么处理啊 可不可用缓存 存起来

​	1.获取数据缓存起来

​	2.用全局变量存起来

​	3.有缓存走缓存  没缓存区请求

```js
//  middlewares.js
  //2. 分类信息
  //2.1 问题 每一次请求 都会去获取分类数据  想做缓存
  //2.2 获取一次分类数据  就存起来 全局变量保存起来
  //2.4 global 是全局对象  暴露给所有的程序使用   不建议这里保存
  //2.5 req res 对象 每次请求重新创建   req.app 对象里面做缓存
  //2.6 思路 如果缓存中有数据  走缓存  没有就发请求给接口服务器获取
 if(req.app.locals.categoryTree){
    res.locals.categoryTree = req.app.locals.categoryTree
    next()
  }else{
    categoryModel.getCategoryTree()
      .then(data => {
        req.app.locals.categoryTree = data
        res.locals.categoryTree = data
        next()
      }).catch(err => next(err))
  }
}
```

### 02.分类查询商品路由规则

​	那接下来是不是 该点击的时候分类查询啊 

​	是不是有两种方式分类查询  第一种点击分类 第二种 搜索

​	那咱们点击的时候路由是不是已经种上了 咱们只需要配置路由就可以了

​	1.router里面配置路由

​	2.controller定义路由需要的方法

​	list/1 为什么不好使啊  是不是路由不匹配啊

​	路由里面加上1 就好使了  但是咱们知道它的后面的参数是多少吗

​	怎么办  大家想想 还知道vue里面的动态路由怎么用吗  是不是 只需要:key就可以了

​	这里面也是  这中风格的url地址叫resultful风格 知识软件的一种架构风格不是 标准啊

​	普通风格： /list/1&id=1   resultful：/list/:id

​	这两个风格那个好那啊  从可读性啊   接口不用我们管啊 是后台定义  我们只需要拿来用就可以了

```js
// 1.router.js配置路由
//restFul 路径规则   url风格
const listController = require('./controllers/list')
router.get('/list/:id',listController.index)
```

### 03.获取restful的参数

​	那我们是不是拿到了id  接下来是不是 根据id获取数据啊

​	那好 首先1. 是不是获取url里面的id  2.根据id发送请求获取数

​	 get：id=10  req.query        post: 看不见 req.body

​	 url/1  怎么拿  req.params

​	 那好 我们来试试   list/1     再试试 list/1/null  结果({"id":"190","name":"null"})

```js
// 2.controllers/list.js
exports.index = (req,res,next) =>{
  	res.json(req.params)
}
```

### 04.获取商品列表数据

​	那id我们拿到了 是不是可以根据id发送axios拿到我们的商品列表数据

​	categories/:id/products拿商品列表信息 但是那 是不是还有分页数据也得拿啊

​	一页显示多少条  显示第几页  是不是接口文档里面都有啊

​	在products.js里面定义方法 获取商品分类和分页数据

​	在list.js 传参调用

```js
 // 1.models/product.js
const axios = require('./axiosInstance')
exports.getProductByCategory = (id, page, per_page, sort) => {
  return axios.get(`categories/${id}/products?page=${page}&per_page=${per_page}&sort=${sort}`)
    .then(res => ({
      list: res.data
    }))
    .catch(err => Promise.reject(err))
}
// 2.controller/list.js 获取某个商品列表
const productModel = require('../models/product')
exports.index = (req, res, next) => {
const id = req.params.id
const page = req.query.page || 1 //获取分页页码
const per_page = 5 //自己约定好的
const sort = req.query.sort || 'commend'
productModel.getProductByCategory(id,page,per_page,sort)
    .then(data=>{
      res.json(data)
}).catch(err=>next(err))
```

### 05.从响应对象中获取分页信息

​	那咱们现在还不能渲染啊  我们是不是 获取了商品列表信息  

​	还有其他数据没有获取 等其他数据都获取完事了 咱们再渲染

​	咱们看看都需要哪些数据啊1.列表2.分页3.面包屑4.排序

​	那好接下来  我们获取分页信息  其实啊 分页数据 人家已经给我们了

​	只是我们现在没拿    问大家一个问题res 是什么 是不是响应对象啊

​	其实它还可以叫响应报文  (响应状态行、响应头、响应主题)

​	res.data响应主题内容    json数据  

​	res.headers 响应的头   包含分页信息

```js
 // 2.models/product.js
//获取分类下的商品列表 包含 分页信息
exports.getProductByCategory = (id, page, per_page, sort) => {
    .then(res => ({
      list: res.data,
      page: +res.headers['x-current-page'],
      total: +res.headers['x-total-pages']
    }))
    .catch(err => Promise.reject(err))
}
```

### 06.排序信息及面包屑信息准备

​	那我们接下来是不是该拿面包屑的数据

​	面包屑的数据接口/categories/:8?include=parent咱们只需要它的父级 测试接口

​	那大家想想 面包屑的数据是不是得和上面2个数据一起拿到渲染  那么用谁啊  是不是用promise.all

​	1.拿到面包屑的数据

​	2.用promise.all包装面包屑和上面的两个数据

​	3.排序信息 是不是得有默认值啊  一开始上来虽然地址来没有但是

```js
面包屑的数据接口/categories/:8?include=parent咱们只需要它的父级 测试接口
// 1.models/category.js获取某一个分类及其父级分类 
exports.getCategoryAndParent = (id) =>{
  return axios.get(`categories/${id}?include=parent`)
    .then(res => res.data) .catch(err => Promise.reject(err))
}
// 2.constroller/list.js 同时获取 列表分页 和 面包屑信息
  Promise.all([
    productModel.getProductByCategory(id,page,per_page,sort),
    categoryModel.getCategoryAndParent(id)
  ]).then(results=>{
    //设置面包屑数据
    res.locals.breadcrumb = results[1]
    //设置当前的排序
    res.locals.sort = sort
    //设置商品列表数据
    res.locals.list = results[0].list
    res.render('list.art')
  }).catch(err=>next(err))
```

### 07.静态的模板准备

```js
{{extend './layout/common.art'}}
{{block 'styles'}}
<link rel="stylesheet" href="/assets/css/page-list.css">
{{/block}}
{{block 'scripts'}}{{/block}}
{{block 'content'}}内容{{/block}}
```

### 08.渲染面包屑导航

​	咱们静态模板准备好了  那接下来是不是该渲染数据了   从上往下说  首先得渲染面包屑数据

​	然后再是排序、列表、分页等 

​	1.获取面包屑数据挂载到locals对象上

​	2.渲染到静态模板

```js
// 1.面包屑数据
<ul class="fl sui-breadcrumb">
{{if breadcrumb.parent && breadcrumb.parent.parent}}
 	<li><a href="/list/{{breadcrumb.parent.parent.id}}">{{breadcrumb.parent.parent.name}}
 {{/if}}            
 {{if breadcrumb.parent}}
   <li><a href="/list/{{breadcrumb.parent.id}}">{{breadcrumb.parent.name}}</a></li>
 {{/if}}
    <li class="active">{{breadcrumb.name}}</li>
</ul>
```

### 09.排序按钮渲染

​	接下来说我们的排序  首先咱们点击的时候 根据传入排序参数 发送请求

​	返回我们想要的数据  首先咱们得把参数种到按钮里的a标签  最后点击的时候是不是 就会根据按钮的不同

​	发送不同的接口  返回不同的数据

​	1.首先把sort方式返回页面res.locals.sort = sort

​	2.li的class  class="{{sort=='commend'?'active':''}}"

​	3.href="/list/{{breadcrumb.id}}?sort=commend

​	4.一开始 默认是降序 不激活   

​	 点击的时候不管升降序都激活   a 的href里面sort值取反

```js
// 2.排序
<ul class="sui-nav">
   <li class="{{sort=='commend'?'active':''}}"><a href="/list/{{breadcrumb.id}}?sort=commend">综合</a></li>
  <li class="{{sort=='quantity'?'active':''}}"><a href="/list/{{breadcrumb.id}}?sort=quantity">销量</a></li>
  <li class="{{sort=='market_time'?'active':''}}"><a href="/list/{{breadcrumb.id}}?sort=market_time">新品</a></li>
  {{if sort.includes('price')}}
     <li class="active">
      <a href="/list/{{breadcrumb.id}}?sort={{sort=='price'?'-price':'price'}}">
     价格 <i class="sui-icon {{sort=='price'?'icon-tb-unfold':'icon-tb-fold'}}"></i>
       </a>
     </li>
   {{else}}
      <li><a href="/list/{{breadcrumb.id}}?sort=-price">价格</a></li>
   {{/if}}
</ul>
```

### 10.列表信息的展示

​	面包屑和排序搞定了  那我们接下来是不是该渲染我们的列表了 

​	数据我们是不是已经拿到了 在results[0]个 直接渲染就行了

​	1.把数据挂载到 locals对象上

​	2.选渲染列表  但是得考虑一个问题  如果没有商品列表怎么处理

```js
// 1.views/list.art列表渲染
{{if list.length }}
<ul class="yui3-g">
       {{each list item i}}
        <li class="yui3-u-1-5">
             <div class="p-img"><a href="/item/{{item.id}}"><img src="{{item.thumbnail}}"></a></div>
             <div class="price"><strong><em>¥</em><i>{{item.price}}</i></strong></div>
             <div class="attr"><em>{{item.name}}</em></div>
             <div class="commit"><i class="command">已有2000人评价</i></div>
             <div class="operate">
             <a href="/cart/add/{{item.id}}" class="r">加入购物车</a>
        </li>
      {{/each}}
</ul>
{{else}}
<div class="sui-msg msg-large msg-block msg-tips">
<div class="msg-con">亲，没有找到该条件下的商品！</div>
<s class="msg-icon"></s>
</div>
{{/if}}
```

### 11.需要的数据分析

​	咱们先来看下渲染按钮需要的数据

### 12.起始按钮&结束按钮-计算思路

​	假如按钮在中间是5

​	1.根据a里面的end 算出start

​	2.在根据b里面的意外情况 得出end 再根据end 算出start

​	3.假如中间数是2 出现意外情况c 第一页码不为0  算start 在根据start算出end

​	4.end还有可能大于总页数 出现d的意外情况

### 13.结束按钮补充意外情况

### 14.封装分页工具类

​	因为两个搜索都用到了 分页  所以我们那他封装成一个分页工具类

​	工具类最终目的的是动态数据结合静态模板生成动态的分页

​	说白了工具类最后能返回分页的html代码  以下4步可以直接写到注释里

​	1.准备分页组件需要的   数据

​	2.准备封装分页组件需要的 模板

​        3.计算起始页码和结束页码

​	4.return html

```js
// 1.utils/pagination.js
//目的是返回分页的HTML格式的代码
const path = require('path')
const template = require('art-template')
module.exports = (options) => {
  /*1. 准备封装分页组件需要的 数据*/
  if (!(options.page && options.total)) return ''
  const {page, total} = options
  const btnNum = options.btnNum || 5 //默认5个按钮
  /*2. 准备封装分页组件需要的 模版*/
  //在  views/component/pagination.art 准备ok
  /*3. 就算 起始页码  和  结束页码*/
  /*a. 理想情况*/
  let end = page + Math.floor(btnNum / 2)
  let start = end - btnNum + 1
  /*b. end 值大于总页数*/
  end = end > total ? total : end
  start = end - btnNum + 1
  /*c. start 值小于1 */
  start = start < 1 ? 1 : start
  end = start + btnNum - 1
  /*d. end 值大于总页数*/
  end = end > total ? total : end

  /*4. 结合数据和模版 动态生产分页HTML格式代码*/
  /*artTemplate 在浏览器端使用  template(模版ID,数据)*/
  /*artTemplate 在NODEJS使用  template(模版路径,数据)*/
  const templateUrl = path.join(__dirname, '../views/component/pagination.art')
  const html = template(templateUrl, {page, total, btnNum, start, end})
  return html
}
```

```js
// 2.调用 controller/list.js
const paginationUtil = require('../utils/pagination')
Promise.all([....]).then(results=>{
    .......
    //需要分页代码
    res.locals.pageHtml = paginationUtil({page:results[0].page,total:results[0].total})
    //artTemplate 输出的html格式的代码 默认是字符串输出  防止xss攻击 cross site script
    res.render('list.art')
  }).catch(err=>next(err))
// 3.views/list.art
{{@pageHtml}}

// 4.views/component/pagination.art模板
{{if total > 1}}
<div class="fr page">
    <div class="sui-pagination pagination-large">
        <ul>
            {{if page > 1}}
            <li class="prev"><a href="#">«上一页</a></li>
            {{else}}
            <li class="prev disabled"><a href="javascript:;">«上一页</a></li>
            {{/if}}
            {{if start > 1}}
            <li class="dotted"><span>...</span></li>
            {{/if}}
            <% for(var i = start ; i <= end ; i++){ %>
            <li class="<%= i==page?'active':'' %>"><a href="#"><%=i%></a></li>
            <% } %>
            {{if end < total }}
            <li class="dotted"><span>...</span></li>
            {{/if}}
            {{if page < total}}
            <li class="next"><a href="#">下一页»</a></li>
            {{else}}
            <li class="next disabled"><a href="javascript:;">下一页»</a></li>
            {{/if}}
        </ul>
        <div>
            <span>共{{total}}页</span>
            <span>到第 <input type="text" class="page-num"> 页 <button class="page-confirm">确定</button></span>
        </div>
    </div>
</div>
{{/if}}
```

### 15.计算起始和结束按钮的页码

​	那我们数据准备好了 接下来是不是该准备静态模板  准备完了 在计算起始和结束按钮

​	在views/compoent/pagination.art静态模板

​	看笔记 直接把业务复制

### 16.直接使用artTemplate生成分页

​	咱们以前使用模板是不是在express 里面用的  它还是可以在前端用和在node里面用

​	//artTemplate  浏览器  template(模板id,数据)

​	//artTemplate  node   template(模板路径,数据)

​	这里是不是需要用到两个包啊 一个是path 一个是art-template

​	1.使用art-template模板

​	2.把模板需要的数据传进去

​	去看笔记

### 17.判断分页按钮

​	模板数据也传进去了  接下来就在我们的模板里面处理逻辑渲染分页

​	1.判断上一页、下一页是否禁用

​		{{if page>1}} <li class="prev">< a href="javascript:;">«上一页</a></li> {{else}}

​           <li class="prev disabled">< a  href="javascript:;">«上一页</a></li> {{/if}}

​	2.判断总页数（小于2页）是否有确定按钮

 		总共多少页共{{total}}页

​		最顶上写它   {{if total>1}} 

​	3.判断是否有省略按钮

​		{{if start>1}}  <li class="dotted"><span>...</span></li>   {{/if}}

​          		中间的5个按钮li

​             {{if end<total}}  <li class="dotted"><span>...</span></li>   {{/if}}

​         4. 中间的5个按钮怎么遍历啊 是不是知道初始值和结束值 就可以了

​	但是我们模板语法 each 是不是没办法办到啊 如果用我们的for循环是不是就可以了

​       去看原始语法

​	 <li class="<%= i==page?'active':''%>">< a href="#"><%=i%></a></li>

### 18.渲染分页按钮

​	分页逻辑处理接下来 是不是应该在list.js里面调用我们的util/pagination.js

​	1.调用分页工具类 传参  

​	2.渲染分页按钮

​	3.render出去list.art

​    1.记住引包pagination.js (render之前调用)

​	 const html = pagination({

​            page: results[0].page,

​            total: results[0].total

​        })	

​	返回的html挂载到locals

​	res.locals.pageHtml=html

​	{{html}}

​     2.模板引擎输出的html格式的代码 默认是字符串(防止xss攻击)

​	@html 输出模板

