**问题:module.exports 和exports区别**

## 模板抽取分析结果

​	今天我们就把首页功能做完   我们来看下首页

​	点开其他是不是很多 地方都一样啊   那咱们是不是得遵循模块化的思想

​	能重用就重用啊  画个图

## 抽离公用模板

![1560588548937](../../../AppData/Roaming/Typora/typora-user-images/1560588548937.png)

​	首先是不是得有basic模板  然后根据图把我们的坑填进去

```js
// common.art
{{extend './basic.art'}}
{{block 'body'}}
    {{include '../component/header.art'}}
    {{block 'content'}}{{/block}}
    {{include '../component/footer.art'}}
{{/block}}
```

​	然后 common模板里面 填body内容就可以了

​	但是 好多页面的  头部和底部 也一样啊  所以说头部和底部是不是也可以重用

​	那可以把头部和底部抽出来  然后用的时候在导进去   用include语法

​	最后只需要继承 common模板 填内容就可以了对吧

​	第一步创建basic模板

​	第二部common模板继承basic模板

​	第三部 剥离头部和尾部 

​	最后是不是谁用 只需要继承common模板填内容就可以

```js
// 路由
app.get('/', (req, res, next) => {
    // 两种写法(自己没试不确定)
// 1. res.locals.site = require('./configs').site
// 2. res.render('home.art',{site:require('./configs').site})
    //配置完中间件以后 res.render('home.art')
// })
```

​	注意地方:

​	1.图片 css style 资源路径  前面加 /

​	2.引入头部尾部  要../

​	3.猜你喜欢改成这样

```js
<li class="yui3-u-1-6">
<a href="item.html" class="pic"><img src="/uploads/like_01.png"></a>
<p>阳光美包新款单肩包女包时尚子母包四件套女</p>
<h3>¥116.00</h3>
</li>
```

## 配置网站头部信息

​	接下来我们看下 首页的功能  是不是 有侧边栏 轮播图 猜你喜欢

​	这是看到的数据  其实还有隐藏的数据  title等  看下京东 头部信息

​	这些数据很重要 主要是用了做SEO的  所以我先把这个数据配置好

​	那怎么配置那啊 首先建一个config.js 这个文件主要是来配置网站的一些公用信息

​	第二步 配置问当头信息  第三步是不是调用啊 但是 大家想一个问题  是不是只要是页面就用这个信息啊

​	所以我们可以把这个公用信息 配置成自定义中间件  路由之前调用  每个页面都可以拿到

​	1.首先创建一个维护网站公用信息的configs.js

​	2.配置文档头信息 

​	3.配置自定义中间件 

​	4.middlewares.js路由之前调用

​	最后页面中调用title

```js
// 1.configs.js
exports.site = {
  title:'品优购title！',
  description:'品优购des。',
  Keywords:'keywords'
}
// 2.middlewares.js
const configs = require('./configs')
exports.global = (req, res, next) => {
  //1. 网站公用的头部信息
  res.locals.site = configs.site
  next()
}
// 3.basic.art
<title>{{site.title}}</title>
<meta name="description" content="{{site.description}}" />
<meta name="Keywords" content="{{site.Keywords}}" />
// 4.路由之前调用
const middlewares = require('./middlewares')
app.use(middlewares.global)
```

## 理解MVC的功能职责

​	直接看笔记

## 控制器拆分

​	大家想想 路由的业务是不是不能放到app.js 不然router.js 干吗呀

​	所以 要把路由业务放到 router.js 处理  然后只要在app.js里面 use一下router.js

​	我们router.js 路由是不是 还得在回调函数里面处理业务啊  业务也可以抽出来来放到conroller里面

​	本来c就是用来处理业务的对吧  

​	1.把路由抽到router里面 然后app调用

​	2.路由回调函数里面的业务 放到controller里面处理

​	3.路由里面导入controller业务处理函数

```js
// 1.router.js
const express = require('express')
const router = express.Router()
const homeController = require('./controllers/home')
//2.添加若干个路由方法
router.get('/', homeController.index)
//3.暴露方法
module.exports = router
```

```js
// 2./controllers/home.js
exports.index = (res, req, nex) => {
    res.render('home.art')
}
```

```js
// 3.app.js
const routers = require('./routers')
app.use(routers)
```



## 使用axios调用接口

​	刚刚我们是不是把home.art  render出去了  咱们想想啊  扔出去之前是不是得 把首页的数据获取到

​	那咱们首页需要什么数据 

​	1.轮播数据2.猜你喜欢数据3.分类数据

​	那这3个数据我们怎么获取啊 c控制m 发送axios  去后台 获取啊

​	演示接口setting  那这样的话我们的models是不是得有一个专门获取setting接口数据 一个js

​        那我们是不是得发送axios 获取数据啊  

​	首先我们是不是得装axios 

​	1.安装axios 2.导入 3.考虑每次请求必须授权  4. 创建axios实例 5.调用

实例里面的值是不是固定不变的  那这样的话  我们是不是可以放在 configs里面

然后导进来但是settings是整个的  咱们是不是想要单个的  下面 settings/:key接口想要什么数据 传什么参数 然后在controller里面调用 获取数据的方法   如果遇到错误往下抛交给错误中间件处理

但是我们调用的时候没有错误  是不是得封装的时候 把错误抛出来  只能这么抛 

试试  res.json(res.locals) 有没有两个数据

```js
// 1.models/settings.js获取其相关接口数据
const axios=require('axios');
// 1.1配置信息放到configs
const {api} = require('../configs')
// 1.2创建axios实例
const instanc=axios.create({
    baseURL:api.baseURL, //请求地址
    timeout：api.timeout,//请求超时时间
    auth:{ //配置认证信息
    	username:api.username,
    	password：api.password
	}
})
// 1.3封装获取轮播数据函数返回promise对象
exports.getSliders = () => {
    return instance.get('/settings/home_slides').then(res => res.data)
}
```

```js
// 2.configs.js 配置公用信息
exports.api = {
    baseURL: 'http://localhost:8000/v1/',
    timeout: 10000,
    username: 'newshop-frontend',
    password: 'd8667837fce5a0270a35f4a8fa14be479fadc774'
}controller调用返回数据函数
```

```js
// 3.controller/home.js
const setttingModels = require('../models/settings')
exports.index = (req, res, nex) => {
    // 1.轮播图数据
    setttingModels.getSliders().then(data => {
        res.locals.sliders = data //挂载数据
        res.render('home.art')
    }).catch(err =>next(err)) //处理错误
    // 2.猜你喜欢数据获取
    // 3.分类数据获取
    // res.render('home.art')
}
```

```js
// 4.models/settings处理axios请求的错误信息
const axios = require('./axiosInstance')
exports.getSilders=()=>{
    return instac.get('/settings/home_slides')
    	.then(res=>res.data)
    	.catch(err=>Promise.reject(err)) //主动调用错误回调方法 交给下一个catch
    	// .catch(err=>return err) 
    	// 直接return err 如果调用请求数据函数 就会把err信息传给它的then方法 当做成功的信息 
}
```

## 提取新axios模块 

​	咱们是不是如果在settings里面设置 axios实例 对吧 那如果再有其他数据 还得实例化配置一遍

​	那咱们是不是得把axios实例配置 抽出来成一个单独模块  调用数据的时候把它过来就行了

​	那好我们就创建一个axiosInstance.js来单独配置我们的axios  首先第一步是不是把axios抽出来

​	第二部 是不是放到一个单独文件 然后抛出方法（module.exports =instance ） 

​	 第三步 是不是 获取数据的时候引入文件  调用方法

```js
// 1.models/axiosInstance.js 提供获取 设置相关数据 的函数
const {api} = require('../configs')
const axios = require('axios')
// 自己创建新的axios实例
const instance = axios.create({
  baseURL: api.baseURL,
  timeout: api.timeout,
  //配置上认证信息
  auth: {
    username: api.username,
    password: api.password
  }
})
module.exports = instance
//2. models/settings.js 引入
const axios = require('./axiosInstance')
```

## 渲染轮播图

​	那好 我们既然把数据拿到了 我们是不是可以渲染了   这样的话 

​	1.测试数据在页面能不能用

​	2.数据循环 渲染轮播图

​	3..渲染完毕以后  res.render('home.art')

注意:$index 索引  $value 每一条数据   两个都得{{$index==0?'active':''}}

```js
// home.art
<ol class="carousel-indicators">
{{each sliders}}
<li data-target="#banner" data-slide-to="{{$index}}" 
class="{{$index==0?'active':''}}"></li>
{{/each}}
</ol>
<div class="carousel-inner">
{{each sliders}}
<div class="item {{$index==0?'active':''}}"><a href="{{$value.link}}"><img
 src="{{$value.image}}"></a></div>
{{/each}}
</div>
```

## Promise.all()方法使用

​	老套路  猜你喜欢 我们是不是得去models建一个 获取数据的js 然后在我们home.js调用渲染

​	大家想一个问题 是不是 我们得等 这3个数据都获取成功以后在渲染 home.art啊  而不是说单个获取渲染啊

​	那这样的话 我们怎么办 给他们说个东西叫promise.all() 它是等所有数据获取成功 在去执行操作

​	那好 1.获取猜你数据 2.promise.all包一下它们两个 3.最后渲染猜你喜欢啊

```js
// 1.models/product.js 获取猜你喜欢数据
const axios = require('./axiosInstance')
exports.getLikeProducts = () => {
  return axios.get('products?type=like&limit=6')
    .then(res => res.data)
    .catch(err => Promise.reject(err))
}
// 2.constroller/home.js
const settingsModel = require('../models/settings')
const productModel = require('../models/product')
exports.index = (req, res, next) => {
//Promise.all()   可以执行多个异步操作 promise  而且会等 最慢的异步结果返回 才回去调用成功的回调
//Promise.race()  可以执行多个异步操作 promise  而且只要 有异步操作返回结果 就回去调用成功的回调
  Promise.all([settingsModel.getSliders(), productModel.getLikeProducts()])
    .then(results => {
      //results 是所各异步操作的返回结构的集合 类型数组  结构的顺序和你传入的顺序一致
      res.locals.sliders = results[0]
      res.locals.likes = results[1]
      //res.json(res.locals) 测试
      res.render('home.art')
    }).catch(err => {
    //只要有一个promise失败就会执行catch
    next(err)
  })
}
```

## 猜你喜欢渲染完成

```js
 {{each likes}}
  <li class="yui3-u-1-6">
  <a href="/item/{{$value.id}}" class="pic"><img src="{{$value.thumbnail}}"></a>
  <p>{{$value.name}}</p>
  <h3>¥{{$value.price}}</h3>
  </li>
 {{/each}}
```

## 定义猜你喜欢接口

​	那这个点击换换 是不是得让数据换啊 那大家想想  我们这个 点击换换能直接

​	发送请求给服务器吗  是不是不能啊   得让中间层替我们去发送请求拿数据啊

​	只需要中间层 把路由暴露给前台  然后点击的时候 走路由 发送axios 去拿数据

​	那大家想想返回给前台的是不是什么格式的数据啊  是不是json格式

​	1.中间层拿到猜你喜欢的数据

​	2.把数据放到 前台请求的层的路由里面 (router里面调用方法)

​	3. 返回json格式的数据

​	注意 拿数据的方法在home.js里面写

​	测试:localhost:5000/like

```js
// 1.router.js
router.get('/like', homeController.like)
```

```js
// 2.conrollers/home.js 返回猜你喜欢json格式数据
exports.like = (req, res, next) => {
  productModel.getLikeProducts().then(data => {
    //以json格式返回
    res.json({status: 200, result: data})
  }).catch(err => {
    //next走错误处理中间件  响应客户端的是错误页面
    //next(err)
    res.json({status: 500, msg: err.message}) //ERROR对象中错误信息  message属性
  })
}
```

## 换一换猜你喜欢

​	接口我们定义好了  那什么时候调用啊

​	是不是点击的时候  那我们前端的操作html 就用jq

​	1.发送ajax拿到数据

​	2.循环渲染页面啊

```js
// 1.home.art前端点击换一换
<script>
  $(function () {
    $('#xxlChg').on('click', function () {
      //发请求 获取数据  渲染
      $.get('/like', function (data) {
        //拼接HTML格式字符串
        let html = ''
        data.result.forEach(function ($value, i) {
            html += `
<li class="yui3-u-1-6">
<a href="/item/${$value.id}" class="pic"><img src="${$value.thumbnail}"></a>
<p>${$value.name}</p>
<h3>¥${$value.price}</h3></li> `})
        $('#picLBxxl').fadeOut(function () {
          $(this).html(html).fadeIn()
        })
      })
    })
  })
</script>
```

## 获取商品分类数据

​	因为很多页面 用到分类数据  那咱们是不是得放到公用信息里面 middlewares里面

​	注意 next在then里面

​	1.获取去分类数据

​	2.middlewares里面调用 挂载到locals对象

​	3.直接可以在模板里面用 （测试 res.json(res.locals)）

```js
// 1.models/category.js 获取去分类数据
const axios = require('./axiosInstance')
exports.getCategoryTree = () => {
  return axios.get('categories?format=tree')
    .then(res => res.data)
    .catch(err => Promise.reject(err))
}
```

```js
// 2.middlewares.js 
const categoryModel = require('./models/category')
exports.global = (req, res, next) => {
  //1.1 网站公用的头部信息
  res.locals.site = configs.site
  //1.2. 分类信息
  categoryModel.getCategoryTree()
    .then(data => {
      res.locals.categoryTree = data
      next()
    }).catch(err => net(err))
}
```

## 渲染分类

分类数据在头部  3分类 

```js
{{each categoryTree item i}}
<div class="item">
<h3><a href="/list/{{item.id}}">{{item.name}}</a></h3>
{{each item.children subItem i}}<dl>
<dt><a href="/list/{{subItem.id}}">{{subItem.name}}</a></dt>
<dd>{{each subItem.children lastItem i}}
<em><a href="/list/{{lastItem.id}}">{{lastItem.name}}</a></em>{{/each}}                
```

